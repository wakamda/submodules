# 7.12 service discovery

服务发现功能是通过广播实现的。

业务层上：
服务提供者server发出广播,告诉组内所有人我提供这个服务；
服务使用者client收到广播后，解析获得对方的ip和port，向服务提供者请求（tcp）使用服务。注：tcp端口和udp使用同一个端口号。

## 广播

广播通信过程：

server：
1. udp client 设置广播使能
2. 绑定广播地址和端口，
3. 发送广播
4. tcp server 接收tcp数据并解析

client：
1. udo server 加入广播组
2. 接收数据并得到服务提供者的ip和端口号
3. tcp client 回复信息

## 问题记录
1. 使用半双工通信还是全双工通信？
服务发现client端发送广播之后，server才能获得地址和port，然后tcp。因此可以使用半双工。
2. 服务发现中有几个udp几个tcp
服务提供者server
需要发送udp广播：一个UDP send
需要接收tcp请求：一个TCP receive
服务使用者client
需要接收udp广播：一个UDP receive
需要发送tcp请求：一个TCP send
3. 关于谁设置端口的问题
服务发现最终的目的是让服务使用者知道server的端口和ip，可以正常tcp请求
而在tcp server中 udp client广播时绑定的端口号 需要是udp server的自身设置的端口号。所以，需要设置udp server和udp client设置的端口号一致。都需要留出接口。且udp和tcp使用的端口号是一个。
4. tcp accept默认是阻塞的。如果使用多线程，主线程用于accept，收到后进入子线程，那么accept是否应该还是阻塞，还是设置成非阻塞？
accept设置成非阻塞。
因为在默认情况下，在使用当前连接的socket和client进行交互的时候，不能够accept新的连接请求。非阻塞之后，有新的连接就可以立刻处理
当然还是在accept中循环，等待新的链接
5. 广播通信中端口设置以及广播地址设置的问题
与其他发送端为client不同，广播中发送广播的一端叫server，server绑定对方client的端口，并设置广播使能和广播地址；
接收广播的一段只需要绑定端口，就可以直接接收广播数据。
总之，**发送的一端需要绑定对方的端口号，因为要发送到对方的那个端口上，ip也是设置对方的ip；receive端需要绑定自己的ip和端口号。**
6. 存放socket发送的数据变量和接受的数据变量应该设置为？全局变量？局部变量？类成员？堆变量？
    1. 这两个变量需要频繁的写入和读出，不适合设置为局部变量
    2. 有时候数据量会很大，不适合设置为栈上实例化的类成员变量
    3. 全局变量存储在全局数据区。
    4. 堆变量使用方便。
7. 关于程序时序的问题
socket编程中，不管是tcp还是udp，server要保证先于client启动并监听端口；服务发现中，如果接收到ip和端口后使用TCP发送，还需要保证发送UDP时使用的端口号在tcp中的端口号没有被占用，且tcp server先于client启动
8. 关于广播地址，和组播地址有什么区别？
广播地址为IP主机段全为1的地址
组播地址
IP 组播通信必须依赖于 IP 多播地址，在 IPv4 中它是一个 D 类 IP 地址，范围从 224.0.0.0 到 239.255.255.255，并被划分为局部链接多播地址、预留多播地址和管理权限多播地址3类：
局部链接多播地址范围在 224.0.0.0~224.0.0.255，这是为路由协议和其它用途保留的地址，路由器并不转发属于此范围的IP包；
预留多播地址为 224.0.1.0~238.255.255.255，可用于全球范围（如Internet）或网络协议；
管理权限多播地址为 239.0.0.0~239.255.255.255，可供组织内部使用，类似于私有 IP 地址，不能用于 Internet，可限制多播范围。
9. 关于服务发现中，服务使用者得到server的IP和port之后：
1.发送TCP消息，还是发送udp消息？
TCP消息的话，无法知道udp绑定的哪个端口，必须要设置固定端口，才可以监听；使用udp单播可以正常监听。

# 第二版 服务发现
由于时序问题，最好是创建多线程，server端主进程用于周期发送广播报文，每次发送后，创建一个子线程，监听tcp连接（accept为阻塞），收到连接请求后处理，处理完成后线程销毁（销毁前主线程不发送广播）。
client端主进程持续监听固定端口的广播报文，每次收到广播后，创建一个子线程，发送tcp连接请求，发送成功后销毁线程。

该模式和单一模式相比没有太大优势，可以直接使用单一进程实现

1. 时序问题
client和server的socket操作时序需要严格遵守，否则就会报错。而且其中还包括tcp和udp的转换，以及循环发送。
从这个角度上将，使用多线程比较方便，因为tcp和udp进入while（1）循环，会有时序不确定性，有一个错误，整体就会失败。
    